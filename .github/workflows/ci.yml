name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.12"
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}
  APP_NAME: reserva-canchas
  DOCKER_BUILDKIT: 1

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: ${{ runner.os }}-pip-
      - name: Install lint deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt ruff black
      - name: Ruff
        run: ruff check .
      - name: Black (check)
        run: black --check .

  types:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: ${{ runner.os }}-pip-
      - name: Install type deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt mypy pydantic
      - name: Mypy
        run: mypy --config-file mypy.ini .

  tests:
    runs-on: ubuntu-latest
    needs: [lint, types]
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: ${{ runner.os }}-pip-
      - name: Install test deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt pytest pytest-asyncio pytest-cov httpx
      - name: Pytest with coverage >= 80%
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: >
          pytest
          --cov=main
          --cov-report=xml
          --cov-report=term
          --cov-fail-under=80
      - name: Generate OpenAPI (artifact)
        run: |
          python - <<'PY'
          import json
          import pathlib
          from fastapi.openapi.utils import get_openapi
          from main import app

          spec = get_openapi(
              title=app.title,
              version=app.version,
              routes=app.routes,
              description=app.description,
          )
          artifacts = pathlib.Path("artifacts")
          artifacts.mkdir(exist_ok=True)
          artifacts.joinpath("openapi.json").write_text(json.dumps(spec, indent=2))
          PY
      - name: Check OpenAPI diff
        run: |
          if [ -f docs/openapi.json ]; then
            diff -u docs/openapi.json artifacts/openapi.json
          else
            echo "docs/openapi.json missing; please commit baseline."
            exit 1
          fi
      - name: Build CI report
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          IMAGE_NAME: ${{ env.APP_NAME }}
        run: |
          python - <<'PY'
          import json
          import os
          import pathlib
          import xml.etree.ElementTree as ET

          artifacts = pathlib.Path("artifacts")
          artifacts.mkdir(exist_ok=True)

          coverage_value = 0.0
          xml_path = pathlib.Path("coverage.xml")
          if xml_path.exists():
              root = ET.parse(xml_path).getroot()
              coverage_value = float(root.get("line-rate", 0.0))

          image = os.environ.get("IMAGE_NAME", "api")
          tag = os.environ.get("IMAGE_TAG", "dev")
          report = {
              "pipeline": "github-actions",
              "status": "success",
              "coverage": round(coverage_value, 4),
              "artifacts": ["openapi.json", f"docker:{image}:{tag}"],
          }
          artifacts.joinpath("ci-report.json").write_text(json.dumps(report, indent=2))
          PY
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ci-artifacts
          path: |
            artifacts/openapi.json
            artifacts/ci-report.json
            coverage.xml

  build:
    runs-on: ubuntu-latest
    needs: tests
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build image (validation)
        env:
          IMAGE_REPO: ${{ env.REGISTRY }}/${{ github.repository }}
        run: docker build --tag "${IMAGE_REPO}:${IMAGE_TAG}" .

  push:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    outputs:
      image_repo: ${{ steps.meta.outputs.image_repo }}
    steps:
      - uses: actions/checkout@v4
      - name: Validate registry credentials
        run: |
          if [ -z "${{ secrets.REGISTRY_USER }}" ] || [ -z "${{ secrets.REGISTRY_TOKEN }}" ]; then
            echo "Missing REGISTRY_USER / REGISTRY_TOKEN secrets"
            exit 1
          fi
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Set image metadata
        id: meta
        run: |
          IMAGE_REPO="${REGISTRY}/${GITHUB_REPOSITORY,,}"
          echo "IMAGE_REPO=$IMAGE_REPO" >> $GITHUB_ENV
          echo "image_repo=$IMAGE_REPO" >> $GITHUB_OUTPUT
      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_TOKEN }}
      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_REPO }}:${{ env.IMAGE_TAG }}
            ${{ env.IMAGE_REPO }}:latest

  deploy-staging:
    runs-on: ubuntu-latest
    needs: push
    if: github.ref == 'refs/heads/main'
    environment: staging
    steps:
      - name: Validate deploy key
        run: |
          if [ -z "${{ secrets.DEPLOY_KEY }}" ]; then
            echo "Missing DEPLOY_KEY secret"
            exit 1
          fi
      - name: Prepare SSH key
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
          DEPLOY_HOST: ${{ vars.STAGING_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if [ -n "$DEPLOY_HOST" ]; then
            ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          fi
      - name: Deploy to staging
        env:
          APP_NAME: ${{ env.APP_NAME }}
          REGISTRY: ${{ env.REGISTRY }}
          REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
          IMAGE_REPO: ${{ needs.push.outputs.image_repo }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          DEPLOY_HOST: ${{ vars.STAGING_HOST }}
          DEPLOY_USER: ${{ vars.STAGING_USER }}
          DEPLOY_PATH: ${{ vars.STAGING_PATH }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PATH" ]; then
            echo "Staging vars missing (STAGING_HOST / STAGING_USER / STAGING_PATH)"
            exit 1
          fi
          ssh "$DEPLOY_USER@$DEPLOY_HOST" <<'EOF'
          docker login ${REGISTRY} -u ${REGISTRY_USER} -p ${REGISTRY_TOKEN}
          docker pull ${IMAGE_REPO}:${IMAGE_TAG}
          docker stop ${APP_NAME} || true
          docker rm ${APP_NAME} || true
          docker run -d --name ${APP_NAME} -p 8000:8000 --restart unless-stopped -v ${DEPLOY_PATH}/.env:/app/.env ${IMAGE_REPO}:${IMAGE_TAG}
          EOF

  deploy-prod:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: ${{ vars.PROD_URL }}
    steps:
      - name: Validate deploy key
        run: |
          if [ -z "${{ secrets.DEPLOY_KEY }}" ]; then
            echo "Missing DEPLOY_KEY secret"
            exit 1
          fi
      - name: Prepare SSH key
        env:
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
          DEPLOY_HOST: ${{ vars.PROD_HOST }}
        run: |
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if [ -n "$DEPLOY_HOST" ]; then
            ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts
          fi
      - name: Deploy to production (requires environment approval)
        env:
          APP_NAME: ${{ env.APP_NAME }}
          REGISTRY: ${{ env.REGISTRY }}
          REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
          REGISTRY_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
          IMAGE_REPO: ${{ needs.push.outputs.image_repo }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          DEPLOY_HOST: ${{ vars.PROD_HOST }}
          DEPLOY_USER: ${{ vars.PROD_USER }}
          DEPLOY_PATH: ${{ vars.PROD_PATH }}
        run: |
          if [ -z "$DEPLOY_HOST" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PATH" ]; then
            echo "Prod vars missing (PROD_HOST / PROD_USER / PROD_PATH)"
            exit 1
          fi
          ssh "$DEPLOY_USER@$DEPLOY_HOST" <<'EOF'
          docker login ${REGISTRY} -u ${REGISTRY_USER} -p ${REGISTRY_TOKEN}
          docker pull ${IMAGE_REPO}:${IMAGE_TAG}
          docker stop ${APP_NAME} || true
          docker rm ${APP_NAME} || true
          docker run -d --name ${APP_NAME} -p 8000:8000 --restart unless-stopped -v ${DEPLOY_PATH}/.env:/app/.env ${IMAGE_REPO}:${IMAGE_TAG}
          EOF
